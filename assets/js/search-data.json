{
  
    
        "post0": {
            "title": "用 Anki 學習任何東西，基礎、模板、元件、工具分享",
            "content": ". 基礎 (Basics) . 學習 Anki 要先從牌組、設定、模板開始認識。你可以觀看下面的影片，了解基本的使用概念。 . . 阿姨我決定要繼續努力了！使用卡片軟體 Anki 學會任何東西 + 輕鬆應付考試 設定 (Settings) . 設定卡片的初始學習進度、未來出現的頻率等，會大幅影響整個使用體驗。最好情況下，你應該針對不同牌組做不一樣的設定。例如針對英文單字牌組，初始學習進度可以複習多次一點，未來出現頻率依照自己的信心來調整。你可以參考 reddit 文章 中的建議來做一些基礎的設定。以下是我自己的設定: . 設定 值 . 新卡片數量 | 30 | . 複習卡上限 | 1000 | . 新卡片學習階段 | 1 20 60 | . 畢業所需 | 2 | . 簡單卡間隔 | 2 | . 忘記 - 重新學習階段 | 1 20 | . 忘記 - 最短間隔 | 2 | . 榨時卡 | 5 | . 榨時卡動作 | 加上標籤 | . 起始輕鬆度 | 2.5 | . 簡單卡片倍率 | 1.3 | . 間隔調節 | 1.0 | . 困難間隔 | 1.2 | . 設定新的間隔 (重來間隔) | 0.25 | . 另外，在 偏好設定 - 排程 裡面，我會把顯示下次複習時間關掉，因為這會影響我選擇 重來、困難、良好、簡單。 . . 模板 (Templates) . 網路上有很多現成的模板，你可以直接把 html, css, js 貼上即可。但通常 模板 會和 筆記欄位 有所關聯，你還是要會一些基本的設定，這些設定都可以到 工具 - 管理筆記類型 調整。另外，你可以參考網路上的新手教學: . 「Leo的Anki系列」1000种Anki模板 | 醫學生的K書法：Anki使用心得（下）- 製作卡片模板 | Anki模板教學：4個小技巧，改成符合你喜愛樣式模板 | 怎么添加漂亮又实用的anki模板？ | . 學會自己修改模板後，就可以引入別人漂亮的模板了: . Troyciv / anki-templates-superlist | git9527 / anki-awesome-select | LoganConnor44 / anki-templates | zantoku / AnkiThemeMountains | ANKI CSS STYLING: CREATING BEAUTIFUL CARDS | Google “Anki Template” 😄 | . . 附加元件 (Add-ons) . Anki 社群 (Community) 有很多附加元件可以使用，你可以到 AnkiWeb - Add-ons for Anki 查看所有的元件。網路上也有很多文章推薦常用的元件，這邊也推薦幾個我有使用的元件: . 元件 功能 截圖 . More Decks Stats and Time Left | 在首頁提供更多今日學習進度。 | | . More Overview Stats 21 | 在學習的卡片中提供更多學習進度資訊。 | | . Review Heatmap | 在首頁提供熱點圖 (heatmap) 觀看全年進度。 | | . Button Colours Good Again | 幫你的按鈕上色。 | | . See Previous Card Ratings in Reviewer | 提供你每張卡片之前的選擇記錄。 | | . AnkiConnect | 讓你能從 Chrome Plugin 等第三方工具直接加入卡片。非常適合搭配英文與日文辭典使用，會在英文工具、日文工具 使用到。 |   | . Quick Colour Changing | 在做筆記的時候可以快速更換文字色彩。 |   | . Syntax Highlighting for Code | 在做筆記的時候可以快速插入程式碼區塊 (code block)。 |   | . 英文 (English Tools) . 我用 anki 搭配許多免費的資源來學習我的英文單字和文法，在 2021/08 拿到多益 950 分，可以參考看看 😄 . 單字 (Vocabulary) . 在线词典助手ODH(划词助手在线版)。這個辭典助手可以幫助你用不同的辭典查詢單字，查詢過後還可以直接加入到你的 anki 當中。你只需要照著這個網頁的教學，將 anki 和這個元件建立連接即可。 . 我搭配這個元件，每天閱讀 email 訂閱的紐約時報 (New York Times Asia)、用英文字幕觀看美劇、訂閱國外 youtuber。考前我也有把 TOEIC 單字表 和 TOFEL 單字表 看過一遍，搭配 Sentencedict 查詢例句。 . 在複習英文單字的時候，我會希望自己能聽到單字就知道意思。如果不知道再看例句前後文回想意思。 . Front Back . | | . 文法 (Grammar) . 我修改 qwiglydee / anki-interactive 的選擇題樣板來建立文法的選擇題。我的文法題目都是來自 test-english。我把文法從 A1 - B2 都做一遍，不會的就會手動加入 Anki 複習。 . Front Back . | | . . 日文 (Japanese Tools) . 和英文類似，我用 anki 搭配許多免費的資源來學習我的日文單字和文法。雖然我有多年大量觀看日劇和動漫畫的經驗，但我是從完全沒有學習過文法的狀況下，花兩個月在 2020/12 拿到 N2 證書 (177分/180分)。一樣可以參考看看 😄 . 單字 (Vocabulary) . 我使用 Yomichan 這個元件當作日文的字典 (英文解釋) 和 Anki 卡片建立的來源。網路上有許多 yomichan 和 anki 連接的教學，例如: . How to Set Up and Use Yomichan with Anki (and SUPERCHARGE your Japanese reading) | 日语学习必备3大网站+3大神器｜furigana+yomichan+anki手把手操作演示❤️ | . 接著就可以帶著 Yomichan 大量閱讀日文相關的文章了。我會每天閱讀 5 篇 NHK 新聞，或從歌詞中學習日文單字。在複習的時候，我會先思考單字的意思和發音，翻到背面才會播放發音和顯示意思。 . Front Back . | | . 文法 (Grammar) . 我是自己設計卡片來記錄文法的，設計的方法是使用 anki 內建的克漏字。我的 N5-N2 文法都是透過 出口日語 還有毎日のんびり日本語教師 來學習。另外，我還有到 jtest4you 練習例題。 . Front Back . | | . . 其他科目 (Others) . Anki 還可以用在其他科目上，例如醫學系常用的 Image Occlusion，可以將圖片重點遮住複習。我自己最近也開始使用 Anki 來做程式碼和一些學科的複習，例如將做過一遍的 LeetCode 題目做成 Anki 卡片來複習，或是將 Git、數學、機器學習等專業知識做成卡片複習。 . azl397985856 / leetcode 有 LeetCode 知識和 Anki 卡片樣板。 | invzhi / LeetCode 有 LeetCode 卡片樣板。 | Peng-YM / LeetCode-Anki 有 LeetCode 卡片自動產生器。 | . 科目 Front Back . LeetCode | | | . Git | | | .",
            "url": "https://jaywang.xyz/anki/2021/11/04/anki.html",
            "relUrl": "/anki/2021/11/04/anki.html",
            "date": " • Nov 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "📌 深度學習的理論目錄 - Collection of Deep Learning Theory",
            "content": "Prerequisite . 建議看完 機器學習的理論 並學會機器學習的基礎概念後，再來研究深度學習。 . Introduction . 深度學習是由機器學習分支出來的一個大領域，其概念是應用神經網路為基礎，並以現今硬體 (特別是 GPU) 效能為輔助，將神經網路建立的越來越大 (深度兩字的由來)。網路內的所有神經元 (neuron) 可以自動學習到問題所需的參數，並以此來預測、解決未知的問題。 . 吳恩達教授的深度學習 1 是我最推薦的深度學習基礎課程之一，這裡一樣是在吸收完教學後，所寫的一些教學筆記；我將所有筆記統整在這裡，方便大家能夠一起學習。 . . 這是新的部落格，目前還在搬運筆記中，舊筆記在: https://sejkai.gitbook.io/academic/deep-learning Catalog . Deep Neural Network (DNN) . 深度學習基礎理論 - 什麼是神經網路 (Neural Network) | 深度學習基礎理論 - 怎麼訓練神經網路 - 反向傳播算法 (Backpropagation) | 深度學習基礎理論 - 怎麼訓練神經網路 - 激勵函數 (Activation Function) | 深度學習基礎理論 - 淺層的神經網路 (SNN, Shallow Neural Network) | 深度學習基礎理論 - 深層的神經網路 (DNN, Deep Neural Network) | 深度學習基礎理論 - 對神經網路正則化 (Regularization) | 深度學習基礎理論 - Dropout 正則化 | 深度學習基礎理論 - 優化神經網路 (Optimization) | 深度學習基礎理論 - Momentum, RMSprop, Adam 優化 | 深度學習基礎理論 - 超參數調整 (Hyperparameter Tuning) | 深度學習基礎理論 - 批量歸一化 (BN, Batch Normalization) | 深度學習基礎理論 - Softmax 函式 (Softmax Regression) | . Convolutional Neural Network (CNN) . 深度學習基礎理論 - 計算機視覺與卷積運算 (Computer Vision and Convolutional Operation) | 深度學習基礎理論 - 卷積神經網路 (CNN, Convolutional Neural Network) | 深度學習基礎理論 - 經典的卷積神經網路 (LeNet-5, AlexNet, VGG) | 深度學習基礎理論 - 殘差網路 (ResNets, Residual Networks) | 深度學習基礎理論 - Inception 網路 | 深度學習基礎理論 - 物件偵測 (Object Detection) | 深度學習基礎理論 - YOLO, You Only Look Once | 深度學習基礎理論 - R-CNN | 深度學習基礎理論 - 人臉識別 (Face Recognition) | 深度學習基礎理論 - 風格轉換 (Neural Style Transfer) | . Recurrent Neural Network (RNN) . 深度學習基礎理論 - 循環神經網路 (RNN, Recurrent Neural Network) | 深度學習基礎理論 - 語言模型 (Language Model) | 深度學習基礎理論 - GRU 和 LSTM (Gated Recurrent Unit &amp; Long Short Term Memory) | 深度學習基礎理論 - 雙向、深度循環神經網路 (Bidirectional RNN &amp; Deep RNN) | 深度學習基礎理論 - 詞嵌入 (Word Embedding) | 深度學習基礎理論 - Word2Vec 詞嵌入 | 深度學習基礎理論 - 情感分類 (Sentiment Classification) | 深度學習基礎理論 - 序列模型 (Seq2Seq, Sequence-to-Sequence Model) | 深度學習基礎理論 - 光束搜尋 (Beam Search) | 深度學習基礎理論 - BLEU (Bilingual Evaluation Understudy) | 深度學習基礎理論 - 注意力模型 (Attention Model) | . Credit . Teached by Andrew Ng, CEO/Founder Landing AI; Co-founder, Coursera; Adjunct Professor, Stanford University; formerly Chief Scientist,Baidu and founding lead of Google Brain | Created by Stanford University | . 1. https://zh-tw.coursera.org/specializations/deep-learning↩ .",
            "url": "https://jaywang.xyz/deep%20learning/recurrent%20neural%20network/rnn/convolutional%20neural%20network/cnn/collection/2021/10/17/collection-of-deep-learning-theory.html",
            "relUrl": "/deep%20learning/recurrent%20neural%20network/rnn/convolutional%20neural%20network/cnn/collection/2021/10/17/collection-of-deep-learning-theory.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "📌 機器學習的理論目錄 - Collection of Machine Learning Theory",
            "content": "Introduction . 吳恩達教授的機器學習 1 是我最推薦的基礎課程之一，他用淺顯易懂的數學就能介紹所有機器學習的基礎理論。這是在吸收完教學後，所寫的一些教學筆記；我將所有筆記統整在這裡，方便大家能夠一起學習。 . . 這是新的部落格，目前還在搬運筆記中，舊筆記在: https://sejkai.gitbook.io/academic/machine-learning Catalog . 機器學習基礎理論 - 什麼是機器學習 (Machine Learning) | 機器學習基礎理論 - 什麼是模型 (Model) | 機器學習基礎理論 - 代價函數 (Cost Function) / 損失函數 (Loss Function) | 機器學習基礎理論 - 梯度下降 (Gradient Descent) | 機器學習基礎理論 - 特徵縮放和學習率 (Feature Scaling &amp; Learning Rate) | 機器學習基礎理論 - 線性回歸 (Linear Regression) | 機器學習基礎理論 - 線性分類 (Linear Classification) | 機器學習基礎理論 - 邏輯斯迴歸 (Logistic Regression) | 機器學習基礎理論 - 過度擬合 (Overfitting) | 機器學習基礎理論 - 偏差還是變異 (Bias vs. Variance) | 機器學習基礎理論 - 怎麼解決過度擬合 - 正則化 (Regularization) | 機器學習基礎理論 - 評估機器學習 (Evaluating Machine Learning) | 機器學習基礎理論 - 什麼是評價指標 (Precision and Recall) | 機器學習基礎理論 - 什麼是支援向量機 (SVM, Support Vector Machine) | . Next . 在學完機器學習的基礎概念後，可以考慮學習以下延伸的主題: . 深度學習的理論目錄 | . Credit . Teached by Andrew Ng, CEO/Founder Landing AI; Co-founder, Coursera; Adjunct Professor, Stanford University; formerly Chief Scientist,Baidu and founding lead of Google Brain | Created by Stanford University | . 1. https://zh-tw.coursera.org/learn/machine-learning↩ .",
            "url": "https://jaywang.xyz/machine%20learning/collection/2021/10/15/collection-of-machine-learning-theory.html",
            "relUrl": "/machine%20learning/collection/2021/10/15/collection-of-machine-learning-theory.html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
  
    
  
    
        ,"post5": {
            "title": "學習 RxJava 結合 Retrofit",
            "content": "個別學習完 RxJava 與 Retrofit 之後，是令人期待的合體了呢 ! 查看前面的文章: . 學習 Android RxJava | 學習 Android Retrofit 2 | . Setup . 設置 Gradle 除了 RxJava 與 Retrofit 的 Library 以外，還要再多設置讓兩者能夠結合的 adapter 套件。 . compile &quot;io.reactivex.rxjava2:rxjava:2.x.y&quot; compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39; compile &#39;com.squareup.retrofit2:retrofit:2.2.0&#39; compile &#39;com.squareup.retrofit2:converter-gson:2.2.0&#39; compile &#39;com.squareup.retrofit2:adapter-rxjava2:2.2.0&#39; . . 要記得 retrofit 與他的快樂夥伴的版本要一致 在設置這邊發生了好多錯誤，原來之前學習時用的是 RxJava1，所以跟 Retrofit2 的 Adapter 配不起來； 1 和 2 有一些差別，可以到 RxJava Github - What’s different in 2.0 查看。 . 實作 Retrofit Service Interface . 一樣拿 GitHub Api 測試看看 : . public interface GitHubService { public final static String BASEURL = &quot;http://api.github.com/&quot;; @GET(&quot;users/{userId}&quot;) Observable&lt;GitHubUser&gt; getUser(@Path(&quot;userId&quot;) String userId); } . 這邊要注意的是原本的 Call 變為 Observable ，因為是用 RxJava 觀察者模式訂閱，所以必須要返回一個 Observable 對象，才能夠進行接續的 `subscribeOn()` 、 `subScribe()` 等 RxJava 操作。其餘的都跟只有 Retrofit 時一樣。 . 創建 Retrofit 元件 . public Retrofit provideRetrofit(String baseUrl) { return new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(baseUrl) .build(); } . 這邊除了原本添加的 Gson 轉換器，還要新增 Retrofit 與 RxJava 相依的 RxJava2CallAdapterFactory 。 . 實作 Retrofit + RxJava 異步網路請求 . GitHubService service = provideRetrofit(GitHubService.BASEURL).create(GitHubService.class); service.getUser(USERID) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(user -&gt; Log.d(TAG, user.getName())); . 先利用 getUser() 獲得 Observable ，再開始使用 RxJava 的方法，能夠歷經 map 、 fliter 、 flatMap ，最後傳給 Observer 進行主執行緒的操作。 . 結語 . 除此之外，若是像設計登入流程，伺服器可能會先回傳一個 token ，需要再以 token 去取得用戶資料。這時可能就要使用 flatMap 再一次發送 token 取得資料。 . 或是登入時需要實作 onError() 的響應，一方面又想要維持 lambda 語法的簡潔，那就必須要另外新增兩個 Action (Consumer) ，來實作 onNext() 、 onError() 的方法，再放入 subScribe 中。 . 上面說的登入設計可以參考這篇文章: . 【Android】RxJava + Retrofit完成网络请求 | .",
            "url": "https://jaywang.xyz/android/rxjava/retrofit/2017/05/05/learn-android-rxjava-with-retrofit.html",
            "relUrl": "/android/rxjava/retrofit/2017/05/05/learn-android-rxjava-with-retrofit.html",
            "date": " • May 5, 2017"
        }
        
    
  
    
        ,"post6": {
            "title": "學習 Android RxJava",
            "content": "為什麼要學習 RxJava . 終於寫到了 RxJava ，前陣子在 掘金 不斷看到這個名字，一直想把他學起來應用在開發上。 看了好多文章，也實際操作，延伸學習了不少新的東西。像是更了解 Android 的執行緒、觀察者模式、 Java 8 的 lambda 語法。雖然我這個新手還沒有做過很大的 Project ，但相信 RxJava 會成為未來一個很棒的工具。 . 記得什麼基礎都沒有時，為了要把網站的圖下載下來顯示到 imageView 中，使用了同步請求，把主執行緒塞爆 UI 當的要死。接著學習了 okhttp、Volley 這些 HTTP 請求的框架，知道了怎麼樣異步處理網路的請求。 但越寫越多，發現自己的程式碼亂七八糟。 . RxJava 就是要讓 “異步操作” 更乾淨、簡潔的實作出來，而且比起 Android 內建的 AsyncTask 或 Handler 更能夠應付越寫越複雜的程式碼。搭配上 lambda 語法，看起來也變得很漂亮。 . 原理 . RxJava 的概念即是觀察者模式 (Observer Pattern) ，由觀察者 (Observer) 與被觀察者 (Subject) 組成。 . . 觀察者 透過訂閱 (Subscribe) 或稱註冊 (Register) 的方式，監控著 被觀察者 。只要 被觀察者 一發生什麼變動，就馬上通知 觀察者 . 就像 Button 註冊 OnClickListener 一樣 : . . RxJava 中的觀察者為 Observer ， 被觀察者為 Observable ， 訂閱的方法為 subscribe()，流程也是類似方式 . 這邊要注意的是，這些方法在 java 中寫起來是長這樣的 : . myButton.setOnClickListener(myOnClickListener); observable.subscribe(observer); . 咦? 這樣看起來不就是 observable 去訂閱 observer 嗎 ? 我也很納悶，在一篇文章這樣解釋著。 . 有人可能會注意到， subscribe() 這個方法有點怪：它看起來是『observable 訂閱了 observer / subscriber』而不是『observer / subscriber 訂閱了 observalbe』，這看起來就像『雜志訂閱了讀者』一樣顛倒了對像關系。這讓人讀起來有點別扭，不過如果把 API 設計成 observer.subscribe(observable) / subscriber.subscribe(observable) ，雖然更加符合思維邏輯，但對流式 API 的設計就造成影響了，比較起來明顯是得不償失的。 . 扔物线 - 給 Android 開發者的 RxJava 詳解 . . Hello, World ! . 先從最基本的回傳字串實際操作看看 ! . 設置 Gradle . compile &#39;io.reactivex:rxjava:1.0.14&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39; . 觀察者 Observer . 先從創建一個觀察者 Observer 看看 : . Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onNext(String s) { Log.d(TAG, &quot;Item: &quot; + s); } @Override public void onCompleted() { Log.d(TAG, &quot;Completed!&quot;); } @Override public void onError(Throwable e) { Log.d(TAG, e.getMessage()); } }; . RxJava 的 Observable 發生改變時，會回傳給 Observer 三種方法，分別是 OnNext() 、 OnComplete() 、 onError() : . OnNext() : Observable 發送過來的訊息，會批次的在這個方法中實現，就像 OnClick() 一樣。 | OnComplete() : 當全部 OnNext() 都被執行完畢，會觸發這個方法。 | onError() : 如果在執行的途中發生錯誤，會馬上執行這個方法，並且中止。 | . 被觀察者 Observable . 接著創建被觀察者 Observable . Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;Hello!&quot;); subscriber.onNext(&quot;World!&quot;); subscriber.onCompleted(); } }); . RxJava 使用 create() 創建一個 Observable，並且丟入參數 OnSubscribe 儲存回 Observable 中，當 Observable 被訂閱後，OnSubscribe 的 call() 方法就會被呼叫。 . 那如何訂閱呢 ? 前面有說過 : . observable.subscribe(observer); // LogCat 就會依序印出 &quot;Hello!&quot;, &quot;World!&quot;, &quot;Completed!&quot; 囉 . . 簡潔化 . 看完了最基礎的用法後，如果每次都要創建 Observer 跟 Observable ，再來 subscribe() 連結關係，好麻煩 ! 所以 RxJava 還有好多必學的用法。 . just . 使用 Observable.just() 來創建 被觀察者 ，與 Observable.create() 所產生的結果是一模一樣的。 . Observable observable = Observable.just(&quot;Hello!&quot;, &quot;World!&quot;); // 一樣會依序印出 &quot;Hello!&quot;, &quot;World!&quot;, &quot;Completed!&quot; . from . Observable.from() 則是能夠讀取繼承 Iterable 的所有類別如 List，並且拆開依序發送出來。 . String[] list = {&quot;Hello!&quot;, &quot;World!&quot;}; Observable observable = Observable.from(list); // 一樣會依序印出 &quot;Hello!&quot;, &quot;World!&quot;, &quot;Completed!&quot; . Action . 簡化了 Observable 的方法後，再來是 Observer 這邊了。 subscribe(Observer) 需要回傳三種方法，在示範中，除了 onNext() 外，其實我們不怎麼需要回傳 onComplete() 與 onError() 。 . 所以 RxJava 提供了 Action 這個 Interface ，包含了 Action0 與 Action1 。 . Action0 與 onComplete 一樣是沒有參數與返回值的，因此可以利用 Action0 實作一個與 onComplete 一樣的方法。 . Action0 onCompletedAction = new Action0() { @Override public void call() { Log.d(TAG, &quot;Completed!&quot;); } }; . 而需要參數的 onError(err) 與 onNext(obj) ， 則利用相同需要傳入參數與返回值的 Action1 來實作。 . Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() { @Override public void call(String s) { Log.d(TAG, &quot;Item: &quot; + s); } }; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() { @Override public void call(Throwable e) { Log.d(TAG, e.getMessage()); } }; . 再來就可以依照需要的 Action 傳入 subscribe() 當中 ! . // 只需要定義 onNext() observable.subscribe(onNextAction); // 以此類推 observable.subscribe(onNextAction, onErrorAction); observable.subscribe(onNextAction, onErrorAction, onCompletedAction); . 練習總結這三種用法 : . public void createActions() { Observable.just(&quot;Hello!&quot;, &quot;World!&quot;).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { Log.d(TAG, &quot;Item: &quot; + s); } }); } . 哇嗚，變得簡潔好多 ! 如果再用之後的 lambda 語法將變得無比華麗呢。 . . 變換函數 . 什麼 ? 你說到現在只是用很炫的方式把字串 print 出來而已 ? 其實現在才要開始看到 RxJava 真正厲害的地方啦 ! RxJava 提供 map 、 flatmap 、 reduce 等方法，將傳進來的每個對象或對象本身進行加工處理並且轉換。 . map . 如果我們有一用戶列表，要抓出全部用戶名字，並添加到新的 List 當中，用一般做法，可能需要用到迴圈之類的麻煩事，但 `map()` 不需要 : . User user1 = new User(); ... Observable.just(user1, user2, user2) // 參數1 : 傳進來的類別 // 參數2 : 轉換完輸出的類別 // 讀進每個 User ， 並轉換為 name 這個 String 傳到下一個 subscribe 方法 .map(new Func1&lt;User, String&gt;() { @Override public String call(User user) { String name = user.getName(); return name; } }) // 將讀取的 name 加到新的 List 中 .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { nameList.add(s); } }); . 例子中的 Func1 這個 Interface ，跟 Action1 相似，同樣傳入參數進入的一個方法。不同的是， Func1 的 call() 是有返回值的 ! 阿 ! 原來數字是多少就是有幾個返回值呢 ! FuncX 就有 X 個返回值 ! 懂了 ! . flatmap . 如果這時要把每個用戶的每個文章標題都列出來，用 map() 的做法會需要用到迴圈 : . Observable.just(user1, user2, user2) .map(new Func1&lt;User, List&lt;Article&gt;&gt;() { @Override public List&lt;Article&gt; call(User user) { return user.getArticleList(); } }) // 將轉換成 List&lt;Article&gt; 傳入 Observer 中 .subscribe(new Action1&lt;List&lt;Article&gt;&gt;() { @Override public void call(List&lt;Article&gt; articleList) { for (Article a : articleList) { Log.d(TAG, a.getTitle()); } } }); . 由於 map() 只能夠實現 1對1 的轉換，所以出現另人煩躁的迴圈了。那要怎麼辦才能在 Observer 中每次都傳入一個 Article 類別呢 ? RxJava 還提供了一個 flatmap() 的方法。 . Observable.just(user1, user2, user2) // User 類別將在 flatmap 中轉換成 Observable&lt;Article&gt; 類別 .flatmap(new Func1&lt;User, Observable&lt;Article&gt;&gt;() { @Override public Observable&lt;Article&gt; call(User user) { return Observable.from(user.getArticleList()); } }) // 即可獲得序列中每個 Article .subscribe(new Action1&lt;Article&gt;() { @Override public void call(Article article) { Log.d(TAG, article.getTitle()); } }); . . 角色 執行 . 紅色 | 進到 flatmap 後，經過新創建的 Observable 將 Article 1 和 Article 2 交給 Observer | . 紫色 | 進到 flatmap 後，經過新創建的 Observable 將 Article 3 和 Article 4 交給 Observer | . 其他轉換函數 . filter : 過濾掉無意義的數據 | reduce : 跟 flatmap 相反，把數個數組組合成一個數據 | . 更多請參考 : 谁来讲讲Rxjava、rxandroid中的操作符的作用? . . Scheduler . 另外一個 RxJava 強大的原因，就是能夠隨意的切換執行緒 (Thread)。我們知道，如果要從事一些網路下載、加載圖片等較為耗時的工作，不能在 Android 的主執行緒，就是 UI 執行緒操作。所以會利用 Thread 或 AsyncTask 操作，類似這樣 : . // 新增一個執行緒來處理圖片 new Thread() { @Override public void run() { super.run(); // 遍步 folder 列表 for (File folder : folders) { File[] files = folder.listFiles(); // 遍步 file 列表 for (File file : files) { // 篩選 png 檔案 if (file.getName().endsWith(&quot;.png&quot;)) { final Bitmap bitmap = getBitmapFromFile(file); // 再回到 ui 執行緒添加圖片 getActivity().runOnUiThread(new Runnable() { @Override public void run() { imageCollectorView.addImage(bitmap); } }); } } } } }.start(); . 但是 RxJava 提供 Scheduler 這個控制器，能夠切換執行緒，這邊先了解 Scheduler 的各種方法 : . Schedulers.immediate() : 直接在當下的執行緒運行，就等於不切換，是默認的方法 | Schedulers.newThread() : 像 new Thread() 一樣啟動一個新執行緒，並在裡面操作 | Schedulers.io(): 便於 I/O 操作的執行緒，與 newThread() 差不多，主要用於讀取文件、db等工作 | Schedulers.computation() : 計算時所使用的執行緒，要與 io 執行緒區別 | AndroidSchedulers.mainThread() : 指定回 Android UI 主執行緒運行 | . 有了這些方法，就能夠在創建 Observable 時，使用 subscribeOn() 和 observeOn() 來進行切換控制。 . Observable.subscribeOn() : 指定 subscribe() 發生時所在的執行緒 | Observable.observeOn() : 指定 subscribe() 返回時 Observer 為了消費事件所在的執行緒 | . 講了難懂，我們來用 RxJava 改造看看剛剛處理圖片的方法吧 : . // 從 folders 取出每個 folder // 再將每個 folder 中的 files 中的 file 各自取出 Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() { @Override public Observable&lt;File&gt; call(File file) { return Observable.from(file.listFiles()); } }) // 過濾出檔名結尾為 .png 的檔案 .filter(new Func1&lt;File, Boolean&gt;() { @Override public Boolean call(File file) { return file.getName().endsWith(&quot;.png&quot;); } }) // 將讀取的每個 File 轉成 Bitmap 輸出 .map(new Func1&lt;File, Bitmap&gt;() { @Override public Bitmap call(File file) { return getBitmapFromFile(file); } }) // 規定以上這些 subscribe 中的工作，都要在 IO 執行緒 操作 .subscribeOn(Schedulers.io()) // 而我們希望最後返回 Bitmap 並顯示在 imageView 的工作，回到 mainThread 執行 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { // 就是 call 裡面的工作在 mainThread 執行 imageCollectorView.addImage(bitmap); } }); . 簡單的加入了 subscribeOn() 與 observeOn() 就讓執行緒能夠隨意切換，真棒 ! . 咦 ? 可是… 怎麼感覺程式碼變多了 ? 仔細看一遍，其實是邏輯變得簡單了呢 ! 程式碼中沒有任何迴圈什麼的，而且一條線的完成了整個工作，非常乾淨。重點是，若隔了好幾個月，突然要加入新的功能進來，用原本的方法寫的程式碼，又不愛加註解，可能要讀個幾分鐘才能搞懂吧 ! 而用 RxJava 的優勢就來了，一下就能搞懂自己當初在幹嘛，並且快速新增新功能進去 ! . 加入 Lambda Function . 或許在 「邏輯」 與 「程式碼」 的簡潔，需要有所取捨。 Java 8 所新增的 Lambda 語法能夠讓 程式碼 變得更簡潔，但相對的會較看不出他的邏輯。 或許應該把 Lambda 的學習在寫一篇文章的 … 不過先用看看，試著起到拋磚引玉的效果吧 . Setup . 要使用 Java 8 的 Lambda 語法，需要在 app Gradle 中配置 (Android Studio 2.3) . android { defaultConfig { ... jackOptions { enabled true } } compileOptions { targetCompatibility 1.8 sourceCompatibility 1.8 } } . 其實自己也還沒有很認真學習過 Java 8 的各種寫法，所以這邊先點出一些常用的方法 : . Lambda 語法 . 這是一般要設定 setOnClickListener 時的做法，可以看到 new View.OnClickListener() 之後的 onClick 方法，看起來太礙眼了，尤其是要定義一堆一樣的 Listener 時，版面之混亂 &gt;_&gt; . button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(TAG, &quot;Hello World!&quot;); } }); . 所以 lambda 語法，提供了一種匿名(Anonymous) 表達式。因為要創建一個 OnClickListener 時，固定只使用到 onClick 方法，並且只要帶入參數 View ，所以就可以簡化成 ` (參數) -&gt; { 工作方法(參數) } ` . button.setOnClickListener(view -&gt; { Log.d(TAG, &quot;Hello World!&quot;); }); // 還可以更簡化 button.setOnClickListener(view -&gt; Log.d(TAG, &quot;Hello World!&quot;)); // 參數可以直接使用 button.setOnClickListener(view -&gt; Log.d(TAG, view.getTag().toString())); . lambda 方法引用 (method reference) . lambda 還能更簡化，這個方法就是方法引用 (method reference) ， 長這樣 :: 。 用法就是，當你指定的 工作方法 中，那個參數跟你原本帶入的參數相同，就可以使用。 有點模糊，試試看 : . // 假如我已經創建好一個方法來執行偵錯，只要帶入 View 就抓出他的 Tag 值 private void show(View view) { Log.d(TAG, view.getTag().toString()); } // lambda 就會知道這個方法可以直接使用 button.setOnClickListener(this::show); . 實際在 RxJava 操作 . 學到這邊一定就知道， RxJava 有一堆 Action、Func 超煩的，來試試把他們簡化，一樣用剛剛處理圖片的流程 : . 由於 map 與 subscribe 都已經有相對方法了，所以 Android Studio 還會問我們要不要改成 方法引用 ，真貼心 ! . Observable.from(folders) .flatMap(file -&gt; Observable.from(file.listFiles())) .filter(file -&gt; file.getName().endsWith(&quot;.png&quot;)) .map(this::getBitmapFromFile) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::showBitmap); . 哇塞，剛剛有一定長度的程式碼，就被縮減為 7 行，而且還保留一定的邏輯在，好有成就感阿 ! . . 結語 . 學會這篇文章的內容，差不多就算入門了 RxJava ，不過 RxJava 還有很多東西可以學習，像是 RxBinding 或是與 Retrofit 一起使用等。這些在邊實作邊學習吧 ! 現在重要的是多用 RxJava 開發，熟能生巧 ! . Reference . 【Android】RxJava的使用（一）基本用法 | 详细解析RxAndroid的使用方式 | 给 Android 开发者的 RxJava 详解 - 扔物线 | .",
            "url": "https://jaywang.xyz/android/rxjava/2017/05/05/learn-android-rxjava.html",
            "relUrl": "/android/rxjava/2017/05/05/learn-android-rxjava.html",
            "date": " • May 5, 2017"
        }
        
    
  
    
        ,"post7": {
            "title": "學習 Android Retrofit 2",
            "content": "Retrofit 2 介紹 . Retrofit 是什麼 ? Retrofit 跟 Volley 一樣是 Android 一種 HTTP 請求的框架，但實際操作了一遍，感覺比 Volley 還要更簡便，而且能夠支援 RxJava。另外，Retrofit 2 使用 REST API 設計，由 RESTful Client 向 Server 發出請求。 . 有關 RESTful API 的相關文章: . RESTful API 设计指南 | 定義 1 - 什麼是 REST/RESTful ? | . . 創建一個能裝載數據的 Class (Model or POJO)， | 創建 Interface 來管理各種 HTTP APIs | 最後創建 REST Client 發出請求，等待回傳 JSON 數據，使用內建的 Gson 解析序列 | . Retrofit 2 基本的用法 . Setup . Gradle 配置 | . compile &#39;com.squareup.retrofit2:retrofit:2.2.0&#39; compile &#39;com.squareup.retrofit2:converter-gson:2.2.0&#39; . 別忘了到 manifest 新增網路的權限 | . &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; . . 創建裝載數據 Class . 這邊可以使用 Android Studio 的插件 GsonFormat ，輕鬆將 JSON 轉換為 JavaBean 類別。 . . 安裝方法: 1. Settings 2. Plugins 3. Browse Repositories 4. 搜尋 GsonFormat 5. restart Step1 Step2 . | | . 就能夠直接產生一個 JavaBean 的類別 ! . public class User { private String name; private String email; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } . 創建 Retrofit 物件與實作 Interface . 假設今天要到 http://www.api.com/user/{userid} 取得 user 的資料。 . Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) // 使用 Gson 解析 .baseUrl(&quot;http://www.api.com/&quot;) .build(); public interface ApiService { // 會返回一個 call 類別 @GET(&quot;user/{userid}&quot;) Call&lt;User&gt; getUser(@Path(&quot;userid&quot;) String userid); } . 創建要去請求 API 的 Client Service . 創建 Api apiService = retrofit.create(ApiService.class); Call&lt;User&gt; call = apiService.getUser(&quot;123&quot;); . | 發出請求 (同步) User user = call.execute(); . | 發出請求 (異步) call.enqueue(new Callback&lt;User&gt;(){ @Override public void onResponse(Response&lt;User&gt; response) { //成功後，使用 response.body() 得到結果 User user = response.body(); } @Override public voidonFailure(Throwable t) { // 請求失敗 } }); . | . . HTTP API 不同的請求方法 . 以下來自官方的文檔，作為記憶之用，請參考 Retrofit Documentation . 另外還可以參考: . Retrofit · Android third-party 使用心得 | Retrofit使用教程(二) | DevWiki Blog | . GET Method . 假設要讀取用戶列表，不用用到任何參數 @GET(&quot;users/list&quot;) Call&lt;List&lt;User&gt;&gt; getUsers(); . | 可以帶入 query @GET(&quot;users/list?sort=desc&quot;) . | URL 帶入參數 @GET(&quot;group/{id}/users&quot;) Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId); . | 若要邊帶入 URL 參數並且 query @GET(&quot;group/{id}/users&quot;) Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @Query(&quot;sort&quot;) String sort); . | . POST Method . 假設要更新使用者資料，需要使用 form-encoded @FormUrlEncoded @POST(&quot;user/edit&quot;) Call&lt;User&gt; updateUser(@Field(&quot;first_name&quot;) String first, @Field(&quot;last_name&quot;) String last); . | 需要利用 multipart 上傳文件 @Multipart @PUT(&quot;user/photo&quot;) Call&lt;User&gt; updateUser(@Part(&quot;photo&quot;) RequestBody photo, @Part(&quot;description&quot;) RequestBody description); . . | . 使用過 Retrofit 的確比 Volley 的用法更簡潔方便了，再來就要試試怎麼樣引入 RxJava 當中。 . 查看前一篇: 學習 Android RxJava | 查看下一篇: 學習 RxJava 結合 Retrofit | . Reference . 【Android】Retrofit 2.0 的使用 | Android Retrofit 2.0使用 | 你真的会用Retrofit2吗?Retrofit2完全教程 | Retrofit2源碼解析 | .",
            "url": "https://jaywang.xyz/android/retrofit/2017/05/02/learn-android-retrofit2.html",
            "relUrl": "/android/retrofit/2017/05/02/learn-android-retrofit2.html",
            "date": " • May 2, 2017"
        }
        
    
  
    
        ,"post8": {
            "title": "學習 Android Data Binding",
            "content": "為了要在 Android 更方便的運作 NVVM 架構， Google 推出了 Data Binding 並且在 Android Studio 2.0.0 版本能夠正式的使用。 . 在還沒遇見 Data Binding 之前，例如要架構一個登入的 Activity ，必須要先去編寫 UI 的 XML ，並給每個需要與用戶互動的 View 一個 View ID 。建構好 UI 的部分後， 再去 java 編寫 findViewById() 、 setText() 、 setVisibility() 、 使用 Picasso 之類的第三方操作圖片⋯。 . 雖然我們可以利用 Butterknife 之類的 Library，降低大量重複煩躁的程式碼，但在更新時還是會同時干涉到 XML 與 java 。有了 Data Binding ，能夠進一步減輕開發的力氣，那就實際操作來學習看看吧。 . Setup . 在 app 的 build.gradle 新增 dataBinding . android { .... dataBinding { enabled = true } } . 最簡單的用法 . 定義 Model . public class User { public User(String name){ this.name = name; } private String name; public String getName() { return name; } } . 定義 layout 檔 . Data Binding 的 layout 檔與以前的寫法不同了。view 不在需要 ID ，不需要再回到 java 依序配對。這表示在未來新增新的 UI 時，會變得更方便。 . &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!-- 重點 1 --&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- 重點 2 --&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.sekaij.ddpractice.User&quot;/&gt; &lt;/data&gt; ...... &lt;RelativeLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{user.name}&quot; tools:text=&quot;username&quot; /&gt; &lt;!-- 重點 3 --&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; . 重點   . 1 | Data Binding 中的 layout 以 &lt;layout&gt; 作為最頂端的節點 | . 2 | 在 &lt;data&gt; 內定義與這個 layout 有相關互動的物件 | . 3 | 使用表達式 @{} 與物件產生連結。我們可以使用 tools 佈置介面 | . 在 Activity 綁定數據 . Data Binding 會依照 layout 檔自動產生 Binding 的 Class ，例如 login_activity.xml ，會產生一個名為 (LoginActivity)Binding 的 Class。 . 他代表了所有我們定義的綁定關係，所以必須在 inflate 創建他，後面在 recyclerView 也是如此。 . public class MainActivity extends AppCompatActivity { private ActivityMainBinding binding; // 自動產生 binding 類別 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.activity_main); User user = new User(&quot;Jay&quot;); binding.setUser(user); // 自動根據 data 中的 variable 產生方法 } } . 表達式 . 回到 @{} 表達式，除了可以利用如 @{user.name} 來綁定數據外，也可以加入一些簡單的邏輯運算。 . // 基本款 &lt;TextView android:text=&quot;@{user.name}&quot;/&gt; // 可以加入 &quot;三元運算子&quot; 來判斷 &lt;TextView android:text=&quot;@{user.age &lt; 18 ? @string/redacted : user.name}&quot;/&gt; // 也可以添加 View 來判斷 VISIBLE &lt;data&gt; &lt;import type=&quot;android.view.View&quot;/&gt; &lt;/data&gt; &lt;TextView android:visibility=&quot;@{user.isAdult ? View.VISIBLE : View.GONE}&quot;/&gt; // 原本需要判斷是否為 null 的三元運算，也能夠使用合併運算符號 ?? 來判斷了 contact.lastName != null ? contact.lastName : contact.name // 如果 lastName 為 null 就用 name ，不為空就使用自己 contact.lastName ?? contact.name . 如果要引入資源時，則利用如 @{@color/white} 方式來引入。 . &lt;... android:background=&quot;@{user.admin ? @color/colorAccent : @color/white}&quot; /&gt; &lt;... android:padding=&quot;@{isBig ? @dimen/bigPadding : @dimen/smallPadding}&quot; /&gt; . 事件處理 (Event) . 一般用法 . 首先先定義 click Event 的類別。 . public class EventHandler { Context context; public EventHandler(Context context) { this.context = context; } // 因為綁定 view ， 所以需要設定參數 view public void onClicked(View view) { Toast.makeText(context, &quot;Success ! &quot;, Toast.LENGTH_SHORT).show(); } } . 別忘了 在 binding 中設定 handler: . EventHandler handler = new EventHandler(this); binding.setHandler(handler); . 接著在 layout 檔定義 handler 的 variable ，並且代入 onclick . &lt;variable name=&quot;handler&quot; type=&quot;com.sekaij.ddpractice.MainActivity.EventHandler&quot;/&gt; // 記得使用 :: // . 已經被棄用 &lt;Button android:onClick=&quot;@{handler::onClicked}&quot; /&gt; . 也可以使用 java 8 提供的 lambda 表達式 . &lt;Button android:onClick=&quot;@{(v) -&gt; handler.onClicked(v)}&quot; /&gt; &lt;!-- 可以不帶入 view --&gt; &lt;!-- public void onClicked() {...} --&gt; &lt;Button android:onClick=&quot;@{() -&gt; handler.onClicked()}&quot; /&gt; . 帶入函數 . User user = new User(&quot;Jay&quot;); binding.setUser(user); EventHandler handler = new EventHandler(this); binding.setHandler(handler); ... public void onButtonClicked(User user) { Toast.makeText(view.getContext(), &quot;Success ! &quot; + user.getName() + &quot; 様&quot;, Toast.LENGTH_SHORT).show(); } . &lt;Button android:onClick=&quot;@{() -&gt; handler.onButtonClicked(user)}&quot; /&gt; . 可觀測性 Observable . Data Binding 還能夠在數據更新時，通知 UI 變動， 只需將要更新變動的 object 繼承 BaseObservable 類別 . public class User extends BaseObservable { private String name; public User(String name){ this.name = name; } @Bindable public String getName() { return name; } public void setName(String name) { this.name = name; notifyPropertyChanged(BR.name); } } . BR 是編譯後產生的一個類別，會去尋找被標註 @Bindable 的 getter 方法，在 BR 中產生對應的值。 當數據更新後， notifyPropertyChanged 會通知系統 BR.name 已經變動，需要更新 UI 。 . ObservableFields . 如果覺得要設定 getter 與 setter 很麻煩，可以設定 ObservableField 以及衍生的 ObservableBoolean 、 ObservableInt ⋯ 等。 . public class ObservableUser { // 一定要加 public final public final ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public final ObservableBoolean isAdmin = new ObservableBoolean(); public ObservableUser(String name, boolean isAdmin) { this.name.set(name); this.isAdmin.set(isAdmin); } } // 定義 ObservableUser observableUser = new ObservableUser(&quot;Jay&quot;, true); // 取得值 String name = observableUser.name.get(); // 設定值 observableUser.name.set(&quot;Wei&quot;); . ObservableArrayMap . 我們還可以使用 key-value 來存取數據，Data Binding 提供了 ObservableArrayMap 類別。 . ObservableArrayMap&lt;String, String&gt; item = new ObservableArrayMap&lt;&gt;(); item.put(&quot;age&quot;, &quot;20&quot;); binding.setItem(item); . &lt;data&gt; &lt;variable name=&quot;item&quot; type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt; &lt;/data&gt; &lt;!-- &amp;lt; 與 &amp;gt; 代替 &lt; &gt; --&gt; &lt;!-- 雖然會顯示錯誤 但編譯正常 --&gt; &lt;TextView android:text=&#39;@{item[&quot;age&quot;]}&#39; /&gt; &lt;!-- 使用 [] 讀取數據 --&gt; . BindingAdapter . 除了基本的設定 setText 以外，當我們要設定圖片時怎麼辦，如果不是從 drawable 讀檔而是從 url ， 如果還想要使用 Picasso ， Glide 等第三方加載圖片時呢？ 這可以用 BindingAdapter 來解決！ . public class CustomDataBindingAdapter { @BindingAdapter(&quot;picasso&quot;) public static void setImageUrl(ImageView view, String url) { Picasso.with(view.getContext()).load(url).into(view); } } . &lt;ImageView app:picasso=&quot;@{user.imgURL}&quot; /&gt; . 如此一來，我們就可以自己定義自己想要的 setter 了！ . 在 @BindingAdapter 註解的後面，也可以放入多個參數如 ： . @BindingAdapter({&quot;imageUrl&quot;, &quot;error&quot;}) public static void loadImage(ImageView view, String url, Drawable error) { Glide.with(view.getContext()).load(url).error(error).into(view); } . &lt;ImageView app:imageUrl=&quot;@{url}&quot; app:error=&quot;@{@drawable/ic_launcher}&quot;/&gt; . RecyclerView 運用 . Data Binding 節省了 ViewHolder 的程式碼，不需要再定義 findViewById ，不需要 holder.location = … ，只需要使用 binding 類別給予的 inflate 進行綁定。 . 定義 Observable 物件與 ClickHandler . public class TimeZone { public final ObservableField&lt;String&gt; location = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; time = new ObservableField&lt;&gt;(); public TimeZone(String loc, String time) { this.location.set(loc); this.time.set(time); } } public interface TimeZoneClickHandler { void onTimeZoneClick(); } . 定義 item layout . &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;timeZone&quot; type=&quot;com.sekaij.ddpractice.TimeZone&quot; /&gt; &lt;variable name=&quot;handler&quot; type=&quot;com.sekaij.ddpractice.TimeZoneClickHandler&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_margin=&quot;16dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{() -&gt; handler.onTimeZoneClick()}&quot;&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:textColor=&quot;@android:color/darker_gray&quot; android:text=&quot;@{timeZone.location}&quot; tools:text=&quot;location&quot; /&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;@{timeZone.time}&quot; tools:text=&quot;time&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; . 定義 ViewHolder . public class TimeZoneViewHolder extends RecyclerView.ViewHolder { private RecyclerViewItemBinding binding; public TimeZoneViewHolder(RecyclerViewItemBinding binding) { super(binding.getRoot()); this.binding = binding; } public void bindTo(TimeZone timeZone) { binding.setTimeZone(timeZone); // binding.setVariable(BR.timeZone, timeZone); // 如果在 xml 定義的 variable 是與他人共用相同的 data ，需要使用這個方法 binding.executePendingBindings(); } public void setHandler(final Context context, final TimeZone timeZone) { binding.setHandler(new TimeZoneClickHandler() { @Override public void onTimeZoneClick() { String location = timeZone.location.get(); String time = timeZone.time.get(); Toast.makeText(context, location + &quot; : &quot; + time, Toast.LENGTH_SHORT).show(); } }); } } . 這邊需要注意的是 executePendingBindings 這個方法，當我們設定數據時，數據綁定要等到下一個動畫幀才會觸發，所以我們才需要這個方法，強制執行更新 UI。 . 定義 Adapter . public class TimeZoneRecyclerAdapter extends RecyclerView.Adapter&lt;TimeZoneRecyclerAdapter.TimeZoneViewHolder&gt; { private ArrayList&lt;TimeZone&gt; timeZoneList = new ArrayList&lt;&gt;(); private Context context; public TimeZoneRecyclerAdapter(Context context, ArrayList&lt;TimeZone&gt; timeZoneList) { this.context = context; this.timeZoneList = timeZoneList; } @Override public TimeZoneViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); RecyclerViewItemBinding binding = RecyclerViewItemBinding.inflate(layoutInflater, parent, false); return new TimeZoneViewHolder(binding); } @Override public void onBindViewHolder(TimeZoneViewHolder holder, int position) { holder.bindTo(timeZoneList.get(position)); holder.setHandler(context, timeZoneList.get(position)); } @Override public int getItemCount() { return timeZoneList.size(); } . 結語 . Data Binding 讓我們能夠在 xml 定義一些表達式，讓 UI 跟 Activity 降低更多耦合，但也不代表我們能把全部的邏輯都放到 xml ， 然後不用再寫 java 。 . 例如我們不應該在 xml 使用一個發送網路訊息的功能。 . &lt;ImageView android:click=&quot;@{webservice.sendMoneyAsync}&quot;/&gt; . 我們應該只處理一些關於 UI 介面的事情。 . &lt;ImageView android:click=&quot;@{presenter.onSendClick}&quot;/&gt; . 到此，還有很多 Data Binding 與 DI 的運用，以及將 Data Binding 帶進更棒的 NVVM 架構！ . Reference . 棉花糖給Android 帶來的Data Bindings | Android Data Binding 系列(一) – 详细介绍与使用 | . 第一個網站為 Android Data Binding 發表的詳細講解，有詳細的講述 Data Binding 背後的運行，所以在這篇文章就不詳細探討，而是實作 Data Binding 的技術。 .",
            "url": "https://jaywang.xyz/android/architecture%20pattern/2017/04/29/learn-android-databinding.html",
            "relUrl": "/android/architecture%20pattern/2017/04/29/learn-android-databinding.html",
            "date": " • Apr 29, 2017"
        }
        
    
  
    
        ,"post9": {
            "title": "學習 Android 依賴注入框架 Dagger2",
            "content": "從上一篇 學習 Android 依賴注入 Dependency Injection (DI) 我們知道，單純的手動使用 DI 進行編寫，會發生不斷依賴反而讓程式碼變得更複雜的問題。所以這次要來學習前人的智慧 DI 框架的使用，我選擇使用 Dagger2 作為學習的框架。不僅僅因為 Dagger2 的名聲響亮， Dagger2 除了被推崇為最好解決 Android DI 的框架，也適合進行單元測試，更棒的是網路上已經有大量的學習文章了！ . 使用 Dagger2 流程 . . @Inject . 回到上次慘不忍睹的程式碼，不斷的創建造成開發效率變得很低。 . public class MainActivity extends AppCompatActivity { private ModuleA moduleA; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ModuleD moduleD = new ModuleD(); ModuleE moduleE = new ModuleE(); ModuleC moduleC = new ModuleC(moduleE); ModuleB moduleB = new ModuleB(moduleC, moduleD); moduleA = new ModuleA(moduleB); } } . Dagger2 使用註解 (Annotations) 來標註 Client 所依賴的 dependency ，這個註解的名字稱作 @Inject 。 . public class ModuleA { private ModuleB moduleB; @Inject public ModuleA(ModuleB moduleB) { this.moduleB = moduleB; } } . 同樣的，也用註解 @Inject 來標註 dependency 的 構造函數 (Constructor) 讓 Client 的 dependency 與 dependency 的 Constructor 產生無形的連結。 . public class ModuleB { private ModuleC moduleC; private ModuleD moduleD; @Inject public ModuleB(ModuleC moduleC, ModuleD moduleD) { this.moduleC = moduleC; this.moduleD = moduleD; } } . @Module . 另一種讓 dependency 之間產生無形連結的方法，就是透過 Module 。 Module 就像一個工廠一樣，我們統一在 Module 裡生產相關的 dependency。 . @Module public class ApplicationModule { public ModuleA provideModuleA(ModuleB moduleB) { return new ModuleA(moduleB); } public ModuleB provideModuleB(ModuleC moduleC, ModuleD moduleD) { return new ModuleB(moduleC, moduleD); } public ModuleC provideModuleC(ModuleE moduleE) { return new ModuleC(moduleE); } public ModuleD provideModuleD() { return new ModuleD(); } public ModuleE provideModuleE() { return new ModuleE(); } } . Module 就是一個 Class ，不過這個 Class 需要用 @Module 來標註，讓 Dagger2 能夠判斷。 創建好 Module 後，就可以在 Module 中生產每個 dependency 了。 . @Provides . 既然 Module 是一個 Class ，那在 Module 中就可以有負責生產 dependency 的 Method ，也可以有負責做其他事情的 Method 。 . 這種專門為了生產 dependency 的 Method 稱作 Provider ，要利用 @Provides 標註。 . @Module public class ApplicationModule { @Provides public ModuleA provideModuleA(ModuleB moduleB) { return new ModuleA(moduleB); } @Provides public ModuleB provideModuleB(ModuleC moduleC, ModuleD moduleD) { return new ModuleB(moduleC, moduleD); } @Provides public ModuleC provideModuleC(ModuleE moduleE) { return new ModuleC(moduleE); } @Provides public ModuleD provideModuleD() { return new ModuleD(); } @Provides public ModuleE provideModuleE() { return new ModuleE(); } } . @Provides 有一個好處，今天要使用 ModuleA 的時候，系統看到 ModuleA 需要 ModuleB ，就會去找其他 Provider ，看有沒有生產 ModuleB 的 Provider ，然後創建一個 ModuleB 給 ModuleA 使用。 如果 ModuleB 還需要其他 dependency ，系統就會繼續找下去，直到所有 dependency 都被滿足。 . Context ? . 那假如今天有一個 Provider 需要 Context 怎麼辦呢，例如 SharedPreferences 。 . @Module public class ApplicationModule { private final Context context; public ApplicationModule(Context context) { this.context = context; } @Provides public Context provideContext() { return context; } @Provides public ModuleD provideModuleD(Context context) { return new ModuleD(context); } } . 之前說過 Module 也是 Class 的一種，那我在產生 Module 時，就可以利用 Module 的 Constructor 引入 Context 囉！ . @Component . 知道了 @Module 和 @Inject 的用法，那要怎麼讓那些被 @Inject 與 @Module 的 dependency 產生直接的連結，然後在 Activity 上被更簡單的創建使用？ . 這就是 Component 大展身手的時候了， Component 扮演了 Injector 的角色，就像注入者一般把那些已經產生無形連結的 dependency 注入 Client 中。 . Component 跟 Module 不同了， 不是 Class 而是 Interface 。當然，也要用 @Component 標註一下。 . @Component public interface ApplicationComponent { } . Component 與 Inject . 今天如果 ModuleA、B、C … 都已經做好 Constructor 的 Inject 時，那要怎麼在 MainActivity 實現 ModuleA 呢。 . @Component public interface ApplicationComponent { void inject(MainActivity mainActivity); } . 首先要在 Component 裡定義一個 inject 的方法，意思就是告訴 Component 到 MainActivity 中，去找所有被 @Inject 的物件。 . public class MainActivity extends AppCompatActivity { @Inject ModuleA moduleA; // Inject 的物件不能設為 private 不然 Component 會找不到 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ApplicationComponent component = DaggerApplicationComponent.builder().build(); component.inject(this); } } . dagger2 會對所有經過 @Component 標註過的 interface 進行處理，自動產生一個實現了這個 interface 的 Class ， Class 的名字就是 Component 的名字前面加上“Dagger”，例如 ApplicationComponent 就會變成 DaggerApplicationComponent 。 . 找到被 @Inject 註解的 ModuleA 之後，Component 繼續去找 ModuleA 的 dependency 被標註的 Constructor ，對應就是被 @Inject 標註的 ModuleB Constructor ，並創建 ModuleB 返回給 ModuleA 。一樣，如果 ModuleB 也有相對應的 dependency ， Component 也會不斷的找下去。 . Component 與 Module . 實際操作時，可能會創建多個 Module 負責不同的 dependency ，也有可能有多個 Component 。 所以要怎麼讓 Component 知道去哪裡找 dependency 呢？ Dagger2 規定，我們必須要指定 Component 負責的 Module 是誰，就在 @Component 註解的後面定義。 . @Component(modules = {ApplicationModule.class}) public interface ApplicationComponent { ModuleA moduleA(); } . 如果 MainActivity 需要 ModuleA ，那我們就在 Component 裡定義一個返回 ModuleA 的方法。 這樣一來， Component 在產生 ModuleA 的時候，就會到 Module 裡面去尋找 ModuleA 相關的 dependency ，一樣創建返回給 ModuleA。 . public class MainActivity extends AppCompatActivity { private ModuleA moduleA; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ApplicationComponent component = DaggerApplicationComponent.builder().build(); moduleA = component.moduleA(); } } . 呼叫 Module 中的 Provider 除了用這種方式，還可以用原本的 Inject 的方式操作。 . @Component public interface ApplicationComponent { void inject(MainActivity mainActivity); } . Component 會到 MainActivity 找所有被 @Inject 的物件，然後回到 Module 中使用對應的 Provider ，在返回給物件。 . 結語 . 到這邊都只是用了簡單的 Inject、Module、Component 來完成 DI ，還有好多 Dagger2 的功能，像是 Singleton、Scope ，怎麼樣分配 Component 的工作，還沒有提到。希望在大量的練習之後，能夠更深入去分析 Dagger2。 . Reference . 小創作- Android單元測試（六）：使用dagger2來做依賴注入，以及在單元測試中的應用 | Android：dagger2讓你愛不釋手-基礎依賴注入框架篇 | .",
            "url": "https://jaywang.xyz/android/dependency%20injection/2017/04/23/learn-android-dagger2.html",
            "relUrl": "/android/dependency%20injection/2017/04/23/learn-android-dagger2.html",
            "date": " • Apr 23, 2017"
        }
        
    
  
    
        ,"post10": {
            "title": "學習 Android 依賴注入 Dependency Injection (DI)",
            "content": "之前學到的幾種 Android 設計架構，都是為了要讓程式碼簡化，使得程式可讀性變高，以及更順利、簡單的進行單元測試。而在 Android單元測試（五）：依賴注入，將mock方便的用起來 這篇文章學習單元測試時，發現依賴注入 (Dependency Injection，DI)能夠讓單元測試變得更容易，甚至可以讓 App 的架構變得更乾淨。究竟 DI 是何方神聖，身為一個入門開發者一定要來學一下。 . 什麼是依賴注入 . 根據 聊聊 Android 中的依賴注入 這篇文章敘述，原來 DI 只是一種 設計模式 (design pattern) ，而且還有許多的框架可以使用。 DI 的目的就是讓開發者能夠寫出”低耦合“的程式碼，不但能更輕鬆的進行單元測試，也幫助維持整個 App 的架構。畢竟如果一款要生存長久的 App ，開發的時間就會越長，往往測試的效率就會慢慢地降低。所以善用 DI 來改善設計，增加可維護性、可拓展性、降低耦合，試著讓程式簡潔優雅一些吧。 . 依賴注入的概念 . 什麼是 Dependency ? . 在 DI 的觀念裡有兩個角色 : Client 、 Dependency ，如果在 App 裡面，有 A Class 用到了 B Class ，那麼 A 就是 Client ，而 B 則是 Dependency 。 . public class ModuleA { private ModuleB moduleB; public ModuleA() { moduleB = new ModuleB(); // A 產生了對 B 的 dependency } } . 什麼是 Injection ? . 上面的程式碼中， B 在外部已經創建好， 接著就像被注入 (Inject) 一般 set 到 Client 的 A裡面，這就算是 DI 的一種方式。但是在上面的例子中 A 和 B 之間還是存在高度耦合，不算是一個很好的 Injection ，一般常用的方法，是透過 client 的 Constructor 將 dependency 傳入。 . public class ModuleA { private ModuleB moduleB; public ModuleA(ModuleB moduleB) { this.moduleB = moduleB; // 將 B 作為 A 的 Constructor 參數傳入 } } . 現在，A Class 不需要知道如何去實現 B ，只要任何繼承了 B 的 Class 都可以傳入，降低兩者間的耦合。 到這邊就是 DI 的概念，簡單。 . 依賴注入的問題 . 習得了 DI 技能馬上就去打 Boss ，發現了一個天大的問題。如果你手動一個一個一個的新增 dependency ，你會發現、你會訝異，所有的 dependency 從最頂端的 Client 一直延伸開來。 . // 如果原本的 ModuleB 也需要兩個 dependency C &amp; D public class ModuleB { private ModuleC moduleC; private ModuleD moduleD; public ModuleB(ModuleC moduleC, ModuleD moduleD) { this.moduleC = moduleC; this.moduleD = moduleD; } } . 而 ModuleC 還需要 Module E ! . public class ModuleC { private ModuleE moduleE; public ModuleC(ModuleE moduleE) { this.moduleE = moduleE; } } . 那可憐 Activity 要呼叫 ModuleA 時就會變成這樣 。･ﾟ･(つд`ﾟ)･ﾟ･ . public class MainActivity extends AppCompatActivity { private ModuleA moduleA; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ModuleD moduleD = new ModuleD(); ModuleE moduleE = new ModuleE(); ModuleC moduleC = new ModuleC(moduleE); ModuleB moduleB = new ModuleB(moduleC, moduleD); moduleA = new ModuleA(moduleB); } } . 有夠亂啊 !!! 還好，前人們在很早以前使用 DI 時早就出現了這樣的問題，所以早就有許多解決使用 DI 問題的框架。 . 依賴注入的框架 . 現在我們的問題是，如果有越來越多的 dependency 被我製造時，這些 dependency 可能會在不同的 client class 被 new 出來， 不但變得更複雜了，而且還重複了一堆程式碼。 . 而在 Java 的領域中，已經有很多框架幫助我們解決問題，例如最近流行的一種框架叫作 Dagger2 。 . 這些框架幫助我們建立一個類似 dependency 的工廠，所有的 dependency ，還是 dependency 的 dependency ，都要統一在這個工廠裡生產。所有要用到這些 dependency 的 client 就去這個工廠取得，而且 client 只需要知道他要用的 dependency 是誰，不需要知道他要的 dependency 又用了哪些 dependency ， 框架系統會自動幫我們判斷。 . 所以接著來學學怎麼使用 Dagger2 吧！看下一篇: 學習 Android 依賴注入框架 Dagger2 . Reference . Android單元測試（五）：依賴注入，將mock方便的用起來 | 聊聊 Android 中的依賴注入 | .",
            "url": "https://jaywang.xyz/android/dependency%20injection/2017/04/22/learn-android-dependency-injection.html",
            "relUrl": "/android/dependency%20injection/2017/04/22/learn-android-dependency-injection.html",
            "date": " • Apr 22, 2017"
        }
        
    
  
    
        ,"post11": {
            "title": "練習在 Android 設計上的 MVC, MVP, MVVM 架構",
            "content": "前言 . 一個人單打獨鬥設計 App ，可能不需要太講究架構，而是注重 App 的完整性與功能性，但是太凌亂的設計開發，反而會降低開發的效率，在未來的維護也會造成很大的麻煩。 . 層次分明、架構清楚漂亮的代碼，能夠實現低耦合的模組化，不但看起來賞心悅目，也讓自己在開發測試上變得更容易。在未來，如果有緣與他人合作，熟悉各種架構寫法的人，肯定也是吃香的。 . 為此，這次要來學習怎麼在 Android 上建立幾種軟體架構。當然，我們不能為了設計而設計，一個簡單的 App ，卻為了設計而花費更多成本，反而本末倒置。 . . 先認識 M - V - X . Model View Controller (MVC) 已經是一種很廣泛流行的架構模式，近幾年也被運用到組織 Android App 上。 隨後衍生的 Model View Presenter (MVP) &amp; Model View ViewModel (MVVM) ，兩種不同的架構也在各種開發者的推崇下，分為好幾派。 . 不過每種架構在開發上都有好有壞，要如何在適當的時機運用適當的架構，讓開發變得更得心應手，才我們真正要學習的，所以這次藉由這篇 Read MVC vs. MVP vs. MVVM on Android ， 試著利用不同的架構，寫出一個 “ 圈叉遊戲 “ ！ . Android 中的 MVC . 在 Model View Controller 的設計理念中， Model 處理數據及邏輯， View 顯示邏輯結果， Controller 則負責起到兩者的橋樑，藉此來達到分離 Model 與 View ，做到高聚合與低耦合的模組化。 . Model . Model 在 “圈叉遊戲” 中，要為我們處理 資料 + 狀態 + 邏輯運算 ，簡單來說就是這個 App 的大腦。 Model 不被綁定在 View 或 Controller ，也因此他還能具備 reuseable 的特質。 . View . View 在此則是擔任將 Model 視覺化的要角。 View 需要去執行 UI 相關的工作，或當 user 與 app 互動時與 Controller 溝通。 他不會參與到太多有關邏輯運算的工作，也不需知道 user 與 app 互動時的狀態為何。 . Controller . Controller 就像膠水一樣把整個 App 聯繫在一起。當 View 告知 Controller 說 User 按下按鈕時， Controller 就要決定怎麼與 Model 互動，產生新的邏輯結果，並且反映更新 View 的介面。 通常在 Android 裡， Activity 與 Fragment 就是擔任 Controller 的角色。 . . 實作 . Model 負責遊戲中三個重要元素 . Board : 運作遊戲的邏輯 (重新開始、換誰下、下在哪裡⋯⋯等) | Cell : 定義遊戲內每一個 cell 的值 | Player : 定義玩家 O , X | . View 負責顯示 OX 遊戲的介面，與 menu 中的 reset 按鈕 . Controller 則擔任與 View 、 Model 互動的角色 . public class TicTacToeActivity extends AppCompatActivity { private Board Model; /* 被引用的 View 物件 */ private ViewGroup buttonGrid; private View winnerPlayerViewGroup; private TextView winnerPlayerLabel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.tictactoe); winnerPlayerLabel = (TextView) findViewById(R.id.winnerPlayerLabel); winnerPlayerViewGroup = findViewById(R.id.winnerPlayerViewGroup); buttonGrid = (ViewGroup) findViewById(R.id.buttonGrid); Model = new Board(); } /* 綁定 reset() 到 menu reset 按鈕 */ @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_reset: reset(); return true; default: return super.onOptionsItemSelected(item); } } // 當 cell 被 user 點擊時觸發， 我們更新 Model 並等待回傳值 Player // 如果這一步其中一個人贏，則顯示&quot;贏家提示&quot;的 View // 否則就將這一步的Player mark 到 cell 裡 public void onCellClicked(View v) { Button button = (Button) v; String tag = button.getTag().toString(); int row = Integer.valueOf(tag.substring(0, 1)); int col = Integer.valueOf(tag.substring(1, 2)); Player playerThatMoved = Model.mark(row, col); if (playerThatMoved != null) { button.setText(playerThatMoved.toString()); if (Model.getWinner() != null) { winnerPlayerLabel.setText(playerThatMoved.toString()); winnerPlayerViewGroup.setVisibility(View.VISIBLE); } } } /* 把&quot;贏家提示&quot;的 View 隱藏及清空 Board ，並告訴 Model 要 restart game 了 */ private void reset() { winnerPlayerViewGroup.setVisibility(View.GONE); winnerPlayerLabel.setText(&quot;&quot;); Model.restart(); for (int i = 0; i &lt; buttonGrid.getChildCount(); i++) { ((Button) buttonGrid.getChildAt(i)).setText(&quot;&quot;); } } } . 結論 . MVC 有效的分離了 View 與 Model ，我們因此可以更簡單的測試 Model ， 也不需要針對 View 進行測試。但在 Controller 的部分還有一些問題: . 靈活度低 : Controller 跟 View 緊密耦合，一但更新了 View 也必須回到 Controller 修改。 | 可測試性 : Controller 綁定了 Android APIs ，很難進行單元測試。 | 維護性低 : 隨著不斷的開發，更多的代碼會被放在 Controller 當中，造成臃腫的現象。 | . Android 中的 MVP . MVP 將 Controller 換成了 Presenter ， 意味著要降低 Controller 與 View 的緊密耦合， 讓 Activity 不再臃腫。 . Model . 與 MVC 一樣，繼續處理 App 的 資料 + 狀態 + 邏輯運算 。 . View . 既然 View 與 Activity 的關係密不可分， MVP 就將 Activity 與 Fragment 也視為了 View 的一部分，並且實作了 View Interface 讓 Presnter 能夠透過 Interface 與 View 產生互動，進而能夠實現單元測試。 . Presenter . Presenter 的工作基本上與 Controller 大同小異，只差在 Presenter 不再綁定 View ，解決了在 MVC 中所遇到的測試性與靈活度問題。 . . 實作 . Model 與 MVC一樣負責 App 的資料邏輯 . View 將 Activity 帶進來，並新增了 View Interface View Interface 幫助 Presenter 與 View(Activity) 進行互動，也就可以模擬 Activity 的行為對 Presenter 進行單元測試 . Presenter 比起 Controller 的寫法更簡單了，不需要一邊處理UI的事情，一邊忙著執行各種動作。 . public interface TicTacToeView { void showWinner(String winningPlayerDisplayLabel); void clearWinnerDisplay(); void clearButtons(); void setButtonText(int row, int col, String text); } . public class TicTacToePresenter implements Presenter { private TicTacToeView view; private Board model; public TicTacToePresenter(TicTacToeView view) { this.view = view; this.model = new Board(); } // 這裡把 Activity 的 Lifecycle 引進， 是從我們 implement Presenter Interface 而來 public void onCreate() { model = new Board(); } public void onPause() { } public void onResume() { } public void onDestroy() { } // 當用戶選擇 cell 時， Presenter 只收到 (row,col)的資訊 ，不需要再在意 View public void onButtonSelected(int row, int col) { Player playerThatMoved = model.mark(row, col); if(playerThatMoved != null) { view.setButtonText(row, col, playerThatMoved.toString()); if (model.getWinner() != null) { view.showWinner(playerThatMoved.toString()); } } } // 需要 reset 時， Presenter 只需下達命令 public void onResetSelected() { view.clearWinnerDisplay(); view.clearButtons(); model.restart(); } } . 結論 . MVC → MVP 之後， 原本 Activity 的邏輯處理跳到了 Presenter ， Activity 變為了 View 的角色，建立 UI 與 Presenter 的連結，最主要的是，View 與 Model 變得不直接互動了，而我們新增的 View Interface ，也更有利於單元測試運作。 現在我們可以單獨測試 Presenter 的邏輯，因為他不屬於任何 View ，而且也讓我們能夠跟不同的 View 進行協同只要 View 有 implement TicTacToeView 。 但在 Presenter 的部分還有一些問題: . 維護性低 : Presenter 與 Controller 一樣，是負責一些附加的邏輯運算。一旦 App 需要不斷演進，開發者就會發現 Presenter 越來越臃腫，代碼量越來越大。 | . Android 中的 MVVM . MVVM 中的 VM 是 ViewModel 的縮寫，透過了 Data Binding on Android 的技術，實現更方便的測試跟模組化，也大量減少為了連結 View 與 Model 的代碼。 . Model . 一樣。 . View . View 被綁定為 Observable variables ，與 ViewModel 可以雙向的互動。 . ViewModel . Data Binding 減輕原本 MVP 中 Presenter 要與 Model 和 View 互動的職責， ViewModel 的工作只需接管 Presenter 剩下的工作，包裝 Model 與 Observable Data 給 View 。 . . 實作 . Model 還是負責 App 的資料邏輯 . View 利用 Data Binding 的方式與 ViewModel 進行溝通 . 在此必須要去學習一下 Android 最新的 Data Binding 可以查看 學習Android Data Binding . ViewModel 負責一些與介面邏輯運算，完成 View 與 Model 的交互 . public class TicTacToeViewModel implements ViewModel { private Board model; // 這些 observable variables 與 view 已經綁定在一起 // 能夠在 ViewModel 更新的同時迅速的更新，並且快速反映在 view 上 public final ObservableArrayMap&lt;String, String&gt; cells = new ObservableArrayMap&lt;&gt;(); public final ObservableField&lt;String&gt; winner = new ObservableField&lt;&gt;(); public TicTacToeViewModel() { model = new Board(); } // 現在這些動作將會被 view 直接呼叫 public void onClickedCellAt(int row, int col) { Player playerThatMoved = model.mark(row, col); cells.put(&quot;&quot; + row + col, playerThatMoved == null ? null : playerThatMoved.toString()); winner.set(model.getWinner() == null ? null : model.getWinner().toString()); } public void onResetSelected() { model.restart(); winner.set(null); cells.clear(); } } . 再來看看 view 的 xml 如何使用 View Binding: . &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; &lt;import type=&quot;android.view.View&quot; /&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.acme.tictactoe.viewmodel.TicTacToeViewModel&quot; /&gt; &lt;/data&gt; &lt;LinearLayout...&gt; &lt;GridLayout...&gt; &lt;Button style=&quot;@style/tictactoebutton&quot; android:onClick=&quot;@{() -&gt; viewModel.onClickedCellAt(0,0)}&quot; android:text=&#39;@{viewModel.cells[&quot;00&quot;]}&#39; /&gt; ... &lt;Button style=&quot;@style/tictactoebutton&quot; android:onClick=&quot;@{() -&gt; viewModel.onClickedCellAt(2,2)}&quot; android:text=&#39;@{viewModel.cells[&quot;22&quot;]}&#39; /&gt; &lt;/GridLayout&gt; &lt;LinearLayout... android:visibility=&quot;@{viewModel.winner != null ? View.VISIBLE : View.GONE}&quot; tools:visibility=&quot;visible&quot;&gt; &lt;TextView ... android:text=&quot;@{viewModel.winner}&quot; tools:text=&quot;X&quot; /&gt; ... &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; . 結論 . MVVM 在測試上變得更加的方便了，因為已經沒有任何綁定在 view元件 身上。在測試時，只需要驗證 observable variables 的設定是否正確，並且在更新時有適當的反映在 view 上。 但 MVVM 並不是萬能，將 data 綁定在 XML 中會有一些問題存在， XML 無法執行單元測試，所以有可能在運行時才發現錯誤，所以要多使用 android 提供的 tools 提高開發的效率。 . Reference . MVC vs. MVP vs. MVVM on Android | Android App的设计架构：MVC,MVP,MVVM与架构经验谈 | 框架模式 MVC 在Android中的使用 | Android中的MVP | Rocko’s blog | .",
            "url": "https://jaywang.xyz/android/architecture%20pattern/2017/04/18/learn-android-architecture-pattern.html",
            "relUrl": "/android/architecture%20pattern/2017/04/18/learn-android-architecture-pattern.html",
            "date": " • Apr 18, 2017"
        }
        
    
  
    
        ,"post12": {
            "title": "學習在 Xcode 8 進行 iOS 上架",
            "content": "第一次要挑戰將 App 上架到 App Store，可是卻發現更新到 Xcode 8 之後，Xcode 預設進行了 Automatically Manage Signing 的動作，自動生成了 App ID 、 Certificate 、 provisioning profiles 。 所以回過頭來，趕快在被 Apple 拒絕退件前，好好學習一下上架相關的流程與 certificate、profiles 等文件之間的關係。 . 註冊 Apple ID &amp; 開發者帳號 iOS Developer Program . 照著網路上的教學，一步一步的走就可以成功註冊: . 好文參考 . iOS App 上架流程, (1/3) 申請 Apple ID for Company - 大兵萊恩 一路直前 | [iOS] Apple iOS Developer Program 開發者帳號 申請實錄 @ 清新下午茶 | . 簽署憑證之間的關係 . 在了解整個上架流程之前，必須先來研究一下什麼是 CSR (Certificate Signing Request) 、Certificate，什麼又是 Provisioning Profiles、 Entitlement。 . 好文參考 . [iOS] App 上架憑證流程筆記 | . Certificate Signing Request . 在向 Apple 申請 Certificate 之前需要在 Mac 上產生 .csr 檔案。 有人翻譯成憑證簽發請求文件，簡稱憑證請求檔，裡面包含了這台 Mac 的一些資訊，以此驗證這台 Mac 身分。並產生成一個私密金鑰 (Private Key)，與一個 .csr 檔案 (公開金鑰) 交付給 Apple。 . Certificate . 有了我們 Mac 的 .csr 檔案後， Apple 作為憑證頒發機構，就可以以他的私鑰簽名在我們的 .csr 檔案， 也就是頒發給我們的證書。用意即 Apple 認證這台電腦是合法的開發者在使用的。 . For Developement 讓我們能夠部暑 App 到裝置上進行測試。 | For Production 用來發佈到 App Store 或進行特殊用途如 TestFlight 。 | . App ID . App ID 就是 APP 唯一的識別名稱，必須要和Xcode裡面的 bundle ID 一樣。 . Explicit App ID 如果 App 有 In-App Purchase 等 Service 功能， App ID 必須是唯一的。比如說 com.apple.MyApp 。 | Wildcard App ID 可以利用像 com.apple.* 含 * 的 ID ， 建立通用的 App ID 給多個 App 使用。 | . Entitlement . 管理一些 Service 的 Capabilities ， 比如 In-App Purchase，Push Notifications，CloudKit 等等。 . Provisioning Profile . Provisioning Profile 就是包含 App ID 、 Certificate 等 App 列表資訊的檔案。 裡面的 Certificate 能證明開發者是誰， App ID 驗證功能授權是否正確，確定測試裝置是否合法。 也就是說 Profile 檔案就是用來規範驗證這個 App 的檔案。 . 上架流程 . . 翻譯成白話文就是 : . 我們在電腦產生 .CSR 檔，帶去 Apple Developer 領取 Certificate | 將 Certificate 安裝到電腦上讓 Apple 能夠識別 | 接著再產生一個 App ID，就能跟 Certificate 一起打包成 Provisioning Profile | 將 Provisioning Profile 安裝到 Xcode ， 讓 Apple 能夠識別 | 在 iTunes Connect 填寫好 App 的資訊、圖片 | 從 Xcode 將 App 打包成 .ipa ， 上傳到 iTunes Connect 準備送審上架 | 好文參考 . 【IOS - APP上架流程圖文教學】– 法蘭克的IOS世界 | iOS App 上架流程 : 一步一腳印的新手教學 | . TestFlight 測試 . 將程式打包至 iTunes Connect 之後， 就可以在 TestFlight 中選取要測試的 prerelease 版本， 然後發送郵件給內部測試的人員 (最多 25 名)。我們也可以邀請外部人員幫忙測試 (1000 名) ， 但是要邀請外部人員公開測試也是要 apple 審核過才行 ! . 好文參考 . [Xcode] 在 iTunes Connect 使用 TestFlight 測試 | iOS 平台如何使用 TestFlight 进行 Beta 测试 | . Xcode 8 - Automatically Manage Signing . 與以往的 Xcode 不同，只要按下 Automatically manage signing ， Xcode 就全自動幫我們管理全部的簽名流程，不管是 Certificate ，還是 Provisioning Profile ，都在後台幫我們將簽名更新到 up-to-date ，我們只需要告訴 Xcode 是哪一個 team 在開發就好。 . . 簡單的畫一下最新的步驟: . . 看起來真簡單! 可是 Automatically manage signing ， 只幫忙簽署 Development 的 Profile ，在 Archive 的時候，也還是使用 Development 的 Profile 。 . 聽說在 Orgnizer 裡選擇 export 到 App Store 的時候，會讓我們重新選擇 Certificate 重新 Signing ，這裡再選擇發布 Distribution 的版本 … 但是這次在 export 的過程中不知為何不斷失敗 … 只好先取消自動化簽名，使用原本的方法上傳 … . 希望下次的上架能夠順利的用新的方式發布成功 ! . 好文參考 . ios - Xcode 8.0 Automatically Manage Signing behaviour - Stack Overflow | WWDC 2016 - Session 401 - What’s New in Xcode App Signing | WWDC 2016 - Session 401 - What’s New in Xcode App Signing 笔记 | .",
            "url": "https://jaywang.xyz/ios/2017/04/16/learn-iOS-distribution.html",
            "relUrl": "/ios/2017/04/16/learn-iOS-distribution.html",
            "date": " • Apr 16, 2017"
        }
        
    
  
    
        ,"post13": {
            "title": "學習 Android 背景執行服務 Android Services",
            "content": "最近為了設計無網路情況下，將資料儲存在SQLite中，而偵測用戶網路連接後，將資料上傳。必須使用到Service的功能，所以剛好有機會把Service學得更深! . Android的Service是Android的四大組件之一。不同於Activity的生命週期，Service可以在背景不斷的工作，直到停止或是系統無法提供資源為止。通常運用在後台播放音樂、定時檢查更新資料，或是執行很久的工作，如上傳及下載檔案。 . 基本概念 . 要讓Service能在後台運行，必須定義一個繼承Service的類別，並在AndroidManifest.xml宣告這個Service以及其他相關屬性，並了解如何啟動他。Service的呼叫分為兩種 : . startService . 當Service使用startService()啟動後，就算Activity被關閉，Service也會持續在Background工作著。Service與Acitivty之間沒有什麼交集，Service完成任務也不會回傳東西給原來的應用程式。 . bindService . 呼叫bindService()則可以讓Activity與Service進行綁定，例如在Activity中指定Service執行某些任務。而bindService也能夠讓Service被多個不同的應用程式呼叫，達到跨應用程式的互動與協作。 . . 應用程式呼叫startService()後，系統呼叫Service類別內的onCreate()，接著呼叫onStartCommand()利用Intent提供的參數做事。直到工作結束或是應用程式呼叫stopService()才會停止。 . | 應用程式呼叫bindService()與Service綁定前，應用程式需要建立一個serviceConnection物件，呼叫後若Service尚未啟動，Service類別內的onCreate()就會被呼叫，使用這種方法啟動Service的應用程式，可以透過onBind()方法取得IBinder物件，接下來就可以透過IBinder物件來取得Service的事件。 . | 做法 . 在AndroidManifest.xml檔中新增定義。 . &lt;? xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot; ?&gt; &lt; manifest xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; package = &quot;com.example.serviceTest&quot; android:versionCode = &quot;1&quot; android:versionName = &quot;1.0&quot; &gt; &lt; uses-sdk android:minSdkVersion = &quot;14&quot; android:targetSdkVersion = &quot;17&quot; /&gt; &lt; application android:allowBackup = &quot;true&quot; android:icon = &quot;@drawable/ic_launcher&quot; android:label = &quot;@string/app_name&quot; android:theme = &quot;@style/AppTheme&quot; &gt; …… &lt; service android:name = &quot;com.example.serviceTest.MyService&quot;&gt; &lt;/ service &gt; &lt;/ application &gt; &lt;/ manifest &gt; . 實作 Service 類別 . 實作一個繼承自Service類別的物件。bindService與startService兩者能夠同時存在並不衝突，而且在這次專案裡剛好都會使用到，所以只要同時實作onStartCommand()與onBind()兩個事件即可。 . public class MyService extends Service { public static final String TAG = &quot;MyService&quot;; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() { super .onCreate(); Log.d(TAG, &quot;onCreate() executed&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.d(TAG, &quot;onStartCommand() executed&quot;); // 執行任務 return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); Log.d(TAG, &quot;onDestroy() executed&quot;); } @Override public IBinder onBind(Intent intent) { return mBinder; } class MyBinder extends Binder { public void startDownload() { Log.d(&quot;TAG&quot;, &quot;startDownload() executed&quot;); // 執行任務 } } } . 在 Activity 實作 (1) . 在Activity中呼叫startService()來執行第一種啟動Service的方法。 . @Override public View onCreate(Bundle savedInstanceState) { setContentView(R.layout.activity_main); super.onCreate(savedInstanceState); Intent intent = new Intent(this, MyService.class); this.startService(intent); } . 在 Activity 實作 (2) . 建立 MyBinder 與 ServiceConnection 物件，並呼叫bindService()執行第二種方法。 . public class MainActivity extends Activity { private MyService.MyBinder myBinder; private ServiceConnection mServiceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder binder) { myBinder = (MyService.MyBinder) service; myBinder.startDownload(); } @Override public void onServiceDisconnected(ComponentName className) { } } @Override public void onResume() { super.onResume(); Intent intent = new Intent(this, MyService.class); this.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); } @Override public void onPause() { super.onPause(); this.unbindService(mServiceConnection); } } . 以上就是關於Android Services的基礎操作，另外還有很多Service相關的東西，如IntentService、Service和Thread的關係、如何運行前台的Service、或者是遠端Service的協作等著學習。 . Reference . Services | Android Developers | Android Service完全解析，关于服务你所需知道的一切(上) | 健行科技Android手機程式設計人才培訓班 - Service背景執行程式 | 《Android》『Service』- 背景執行服務的基本用法 | .",
            "url": "https://jaywang.xyz/android/android%20services/2017/04/04/learn-android-services.html",
            "relUrl": "/android/android%20services/2017/04/04/learn-android-services.html",
            "date": " • Apr 4, 2017"
        }
        
    
  
    
        ,"post14": {
            "title": "學習版本控制基礎 - Git & Gitlab",
            "content": "版本控制是什麼，為什麼要學 . 剛開始踏入軟體工程師的工作，懵懵懂懂的開發了兩個App，很菜的還真的自己新建了好多資料夾，複製了好幾次更新的Project，開新文字檔標示每個的差異。這時才發現原來有版本控制這種東西。 . 上網查了一下，版本控制已經有一段歷史，從集中式版本控制的CVS、Subversion等，到現在流行的分散式版本控制系統Git或Mercurial。這時才慢慢了解Git與Github的差別在哪裡哈哈，原來Github不只有大量的資源，而且正是給予本地端Git存取的站點。 . 有了版本控制，不但能輕鬆管理每一個版本的程式碼，還可以將檔案復原到原本的狀態、比對某一段時間的修改，甚至在未來，如果要跟多個工程師共同處理一個案子時，不需要帶著隨身碟到處跑來跑去，交換檔案，只需要透過版本控制管理，就能馬上了解對方做了什麼修改。 . Git 基礎 . 簡單來說，Git分為在本地端數據庫操作以及跟遠端數據庫的同步與共享，我們可以在本地端使用像是還原更改等所有Git版本控制功能，但若想要公開本地端的修改內容，或與他人共同修改內容，就必須要透過遠端數據庫的幫忙。 . . 要將檔案進行版本管理必須要走一段路，分別是工作目錄(Working Tree)、索引(Index)、數據庫(Repository)。 . 數據庫 : 記錄檔案或目錄狀態的地方，儲存專案的修改歷史記錄，還可以追蹤內容的狀態和版本 | 工作目錄 : 便是我們處理專案的目錄，Git的操作指令都在這裡完成 | 索引 : 為了要將專案上傳到數據庫而準備的暫存區 | . . 索引的存在可以排除工作目錄裡不必要的檔案提交，還可以只將檔案變更內容的一部分加入索引並提交。 . 本地端數據庫 . 安裝 . 首先必須先安裝Git，Windows用戶可以到Git官網安裝，而Mac用戶可以下載OSX Git installer進行安裝。 以下先以windows環境操作Git，在Windows安裝之後，從開始選單&gt; 所有程式&gt; Git&gt; Git Bash . 設定 . 首先先設定使用者的資料，這些資訊將作為提交者資訊顯示在版本控制的歷史記錄中。 . $ git config --global user.name &quot;&lt;使用者名字&gt;&quot; $ git config --global user.email &quot;&lt;電子信箱&gt;&quot; # 可以為Git的命令設定別名，例如：「checkout」可以省略為「co」來執行。 $ git config --global alias.co checkout # 可以讓含有中文的檔名可以正確顯示。 $ git config --global core.quotepath off . 新建數據庫並新增一個檔案 . 設定好Git後，試著建立一個專案並且使用git init，將專案與數據庫連接。 接著我們在專案中新增一個test.txt的文字檔。 . $ mkdir test $ cd test $ git init $ cd test $ touch test.txt . 確認工作目錄與索引的狀態 . 馬上來查看這個文字檔的狀況，發現他尚未被加入到索引中。 . $ git status # On branch master # # Initial commit # # Untracked files: &lt;-- 還未被加入 # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) # # test.txt . 將檔案加入到索引 . 可以使用 git add &lt;檔案名稱&gt; 將檔案加入至索引。 也可以使用 git add . 將所有未加入的檔案一次加入。 此時可以看到文字檔已經待命被提交到數據庫了。 . $ git add test.txt $ git status # On branch master # # Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) # # new file: test.txt . 執行commit命令提交檔案 . 最後只要執行 git commit -m &quot;更新註解&quot; 就可以將本次更新的內容提交到數據庫了。 也可以使用 git commit -am &quot;更新註解&quot; 將 git add 一併執行。 . $ git commit -m &quot;first commit test file&quot; #使用log命令來顯示數據庫的歷史提交記錄。 $ git log commit 448a63e7975d7583732f0210e6076fd2ac698413 Author: Jay &lt;windsuzu@gmail.com&gt; Date: Wed Mar 29 20:54:25 2017 +0800 first commit test file . . 遠端數據庫 . 在GitLab上建立遠端數據庫 . 處理、更新完成本地端的專案後，再來就可以將專案上傳到遠端的數據庫。將專案放到遠端的數據庫，不但能方便多人共同開發，且若臨時換到其他電腦進行作業，也能夠將專案與更新的歷史紀錄一併下載到另外一台電腦上。 在選擇遠端的數據庫上，可以使用目前最流行的GitHub，除了進行版本控制外，還可以公開自己所寫的專案，讓各大神人診斷、指導。但是若要在GitHub建立私人的數據庫，需要申請付費帳戶，所以我決定使用GitLab。 . GitLab的介面、功能都與GitHub十分相似，可以參考這些網站，馬上註冊操作看看 : . GitLab工作流程 | Getting started with Git and GitLab | . 新增Repository . 在GitLab註冊好帳戶後，為專案新增一筆數據庫。 . . 取得了遠端數據庫的URL後，就可以將本地端的專案上傳上來，為此，需要在Git執行Push(推送)操作。 在那之前，先為遠端數據庫取個適合的別名或暱稱。利用$ git remote add &lt;name&gt; &lt;url&gt;這個方法。 . $ git remote add origin https://SekaiJ@gitlab.com/SekaiJ/test.git . 當要push變更到遠端數據庫時，加上&lt;repository&gt;指定要push的地址，&lt;refspec&gt;指定要push的分支。 也就是$ git push &lt;repository&gt; &lt;refspec&gt; . $ git push origin master . 上傳成功後，便可以在GitLab上看到成果囉! . . 之後如果使用其他電腦，或在本地端沒有專案檔案時，能夠使用clone命令來複製遠端數據庫。 $ git clone &lt;repository&gt; &lt;directory&gt; . $ git clone https://SekaiJ@gitlab.com/SekaiJ/test.git test . 與其他人共同修改專案時，使用pull命令則可從遠端數據庫下載最新的修改內容到本地數據庫。 $ git pull &lt;repository&gt; &lt;refspec&gt; . $ git pull origin master . 學到這裡，還只接觸到了Git的基礎呢! 在未來，如果能夠跟很多神人共同開發專案，那還必須學習分支(Branch)、合併(Merge)，還有很多不同的指令，與一些解決衝突的方法。 . Reference . 網路上已經有大量的Git教學文章及影片，都淺顯易懂，這邊列舉幾個： . Git 教學(1) : Git 的基本使用 | 連猴子都能懂的Git入門指南 | Learn Git in 20 Minutes | .",
            "url": "https://jaywang.xyz/git/2017/03/28/learn-git.html",
            "relUrl": "/git/2017/03/28/learn-git.html",
            "date": " • Mar 28, 2017"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Past and present . Hello, I am Jay, and I was born in 1996. I graduated from National Cheng Kung University with a Master&#39;s degree in Artificial Intelligence in July 2021. My master&#39;s thesis is related to deep learning and natural language processing. I am proud of my self-learning ability. For example, I taught myself to write Android and iOS applications in my previous job; I studied computer science subjects on my own and passed my master&#39;s exam. I also learned Japanese and English in my spare time without spending any money. I am confident in my problem-solving and googling skills. For any task or program error, I can almost always find the solution independently. In addition, I constantly improve my ability to communicate and solve problems with other programmers. I am passionate about design and presentation. I like to design my websites, blogs, applications, and other works. I also enjoy making slides and sharing, teaching stuff to my classmates or colleagues. Because I love teaching, I created this blog and dedicated myself to creating content that either I or anyone would want to read again and again.",
          "url": "https://jaywang.xyz/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Portfolio",
          "content": "Machine Learning Deep Learning Front-End Others",
          "url": "https://jaywang.xyz/portfolio/",
          "relUrl": "/portfolio/",
          "date": ""
      }
      
  

  
      ,"page4": {
          "title": "Résumé",
          "content": ". Oops! Your browser does not support PDFs! . Download Instead .",
          "url": "https://jaywang.xyz/resume/",
          "relUrl": "/resume/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaywang.xyz/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}